"use strict";(self.webpackChunkmy_react_learning=self.webpackChunkmy_react_learning||[]).push([[57],{57:(e,t,s)=>{s.r(t),s.d(t,{default:()=>o});s(43);var n=s(579);const o=()=>(0,n.jsxs)("div",{children:[(0,n.jsx)("h1",{children:"Hooks"}),(0,n.jsx)("p",{children:'Hooks are functions that let you use state and other React features. Hooks are the new addition in React 16.8. They let you use state and other React features without writing a class. Hooks are backward compatible. Hooks are functions that let you "hook into" React state and lifecycle features from function components. Hooks are JavaScript functions, but they impose two additional rules:'}),(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:"Only call Hooks at the top level."}),(0,n.jsx)("li",{children:"Only call Hooks from React functions."})]}),(0,n.jsx)("h2",{children:"There are 10 built-in Hooks in React:"}),(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:"useState"}),(0,n.jsx)("li",{children:"useEffect"}),(0,n.jsx)("li",{children:"useContext"}),(0,n.jsx)("li",{children:"useReducer"}),(0,n.jsx)("li",{children:"useCallback"}),(0,n.jsx)("li",{children:"useMemo"}),(0,n.jsx)("li",{children:"useRef"}),(0,n.jsx)("li",{children:"useImperativeHandle"}),(0,n.jsx)("li",{children:"useLayoutEffect"}),(0,n.jsx)("li",{children:"useDebugValue"})]}),(0,n.jsx)("h2",{children:"Advantages of Hooks:"}),(0,n.jsxs)("ul",{children:[(0,n.jsx)("li",{children:"Code Reusability"}),(0,n.jsx)("li",{children:"Code Readability"}),(0,n.jsx)("li",{children:"Code Maintainability"}),(0,n.jsx)("li",{children:"Code Organization"}),(0,n.jsx)("li",{children:"Code Consistency"}),(0,n.jsx)("li",{children:"Code Performance"}),(0,n.jsx)("li",{children:"Code Quality"}),(0,n.jsx)("li",{children:"Code Scalability"}),(0,n.jsx)("li",{children:"Code Simplicity"}),(0,n.jsx)("li",{children:"Code Consistency"})]}),(0,n.jsx)("h2",{children:"Disadvantages of Hooks:"}),(0,n.jsx)("p",{children:"Learning Curve: Hooks require learning a new way of writing React components, which might take time for developers used to class-based components. Breaking Changes: Transitioning existing code to hooks may cause issues, and older React versions don't support them. Complexity in Large Components: Using many hooks in large components can make the code harder to understand. Lifecycle Abstraction: Hooks abstract away the component lifecycle, which might make it less clear how and when certain actions happen. Custom Hook Overuse: Using custom hooks excessively can make code harder to follow. Tooling and Type Safety: Some tools and type safety features may not fully support hooks yet. Performance Concerns: Misusing hooks can lead to performance problems, like unnecessary re-renders."}),(0,n.jsx)("h2",{children:"useState: useState is a Hook that allows you to have state variables in functional components. useState returns an array with two elements. The first element is the current value of the state, and the second element is a state setter function. You can pass an initial value to useState. The initial value is used only during the first render. useState returns the current state and a function that lets you update it. useState is a new way to use the exact same capabilities that this.state provides in a class."}),(0,n.jsx)("h2",{children:"useEffect:"}),(0,n.jsx)("p",{children:"useEffect is a Hook that lets you perform side effects in function components. useEffect is a close replacement for componentDidMount, componentDidUpdate, and componentWillUnmount in React classes. useEffect is called after the component is rendered. useEffect is called after the component is updated. useEffect is called after the component is unmounted. useEffect is called after the component is mounted. useEffect is called after the component is unmounted. useEffect is called after the component is updated. useEffect is called after the component is rendered. useEffect is called after the component is mounted. useEffect is called after the component is unmounted. useEffect is called after the component is updated. useEffect is called after the component is mounted. useEffect is called after the component is unmounted. useEffect is called after the component is updated."}),(0,n.jsx)("h2",{children:"useContext:"}),(0,n.jsx)("p",{children:"useContext is a Hook that allows you to use the context in functional components. useContext is a close replacement for static contextType in React classes. useContext is a close replacement for Context.Consumer in React classes. useContext is a close replacement for Context.Provider in React classes. useContext is a close replacement for Context.displayName"}),(0,n.jsx)("h2",{children:"useReducer:"}),(0,n.jsxs)("p",{children:["useReducer is a built-in React hook that provides an alternative to useState for managing complex state logic in React components. While useState is generally used for managing simple state values or objects, useReducer is more suitable for managing state that involves multiple sub-values or complex update logic. The useReducer hook follows the same principles as the Reducer function in JavaScript, which is commonly used with the Array.reduce() method. It takes in a reducer function and an initial state, and returns the current state and a dispatch function",(0,n.jsx)("span",{children:"Here's the basic syntax of useReducer: const [state, dispatch] = useReducer(reducer, initialState);"}),"state: Represents the current state value. dispatch: A function used to dispatch actions to update the state. reducer: A function that specifies how the state should be updated based on the dispatched action and the current state. initialState: The initial state value."]}),(0,n.jsx)("h2",{children:"useCallback:"}),(0,n.jsx)("p",{children:" useCallback is a Hook that returns a memoized version of the callback\n            function that only changes if one of the dependencies has changed. It\n            is useful when passing callbacks to optimized child components that rely\n            on reference equality to prevent unnecessary renders. useCallback(fn,\n            deps) is equivalent to useMemo(() => fn, deps).\n            "}),(0,n.jsx)("h2",{children:"useMemo:"}),(0,n.jsxs)("p",{children:[" useMemo is a Hook that returns a memoized value. It is similar to\n            useCallback, but it memoizes the result of the function call instead of\n            the function itself. useMemo(fn, deps) is equivalent to useCallback(() =>\n            fn(), deps).\n            ",(0,n.jsx)("br",{}),"useMemo is a built-in React hook that memoizes the result of a function, preventing unnecessary re-computation of that function's result on re-renders. It is used to optimize performance by caching the result of expensive computations and only recalculating them when one of the dependencies has changed."]}),(0,n.jsx)("h2",{children:"useRef:"}),(0,n.jsx)("p",{children:"useRef is a built-in React hook that returns a mutable ref object whose .current property is initialized to the passed argument (initialValue). The returned object will persist for the full lifetime of the component. useRef is commonly used to store references to DOM elements or values that need to persist between renders without triggering a re-render."}),(0,n.jsx)("h2",{children:"useImperativeHandle:"}),(0,n.jsx)("p",{children:"useImperativeHandle is a built-in React hook that allows a parent component to interact with a child component's imperative methods or properties. It is commonly used in conjunction with forwardRef to expose specific methods or properties of a child component to its parent. useImperativeHandle(ref, createHandle, [deps]) ref: A ref object created using the useRef hook. createHandle: A function that creates the imperative handle. deps: An optional array of dependencies that, when changed, will trigger the creation of a new handle."}),(0,n.jsx)("h2",{children:"useLayoutEffect:"}),(0,n.jsx)("p",{children:"useLayoutEffect is a built-in React hook that is similar to useEffect, but it fires synchronously after all DOM mutations. It is commonly used to perform imperative DOM operations that require synchronous measurements or side effects. useLayoutEffect(fn, deps) is similar to useEffect, but it fires synchronously after all DOM mutations. It is commonly used to perform imperative DOM operations that require synchronous measurements or side effects."}),(0,n.jsx)("h2",{children:"useDebugValue:"}),(0,n.jsx)("p",{children:"useDebugValue is a built-in React hook that can be used to display a label for custom hooks in React DevTools. It is commonly used to provide additional information about custom hooks when inspecting them in the React DevTools. useDebugValue(value) value: The value to display in React DevTools."}),(0,n.jsx)("h2",{children:"Custom Hooks:"}),(0,n.jsx)("p",{children:"Custom Hooks are JavaScript functions that allow you to reuse logic across multiple components. They are a way to extract and share common logic between components without repeating code. Custom Hooks follow the naming convention useSomething, where Something is a descriptive name for the logic being shared. Custom Hooks can use other Hooks, including built-in Hooks and other custom Hooks. Custom Hooks can accept arguments to customize their behavior. Custom Hooks can return values to be used in the component. Custom Hooks can be shared and reused across different components. Custom Hooks can be tested like regular functions. Custom Hooks can be used to encapsulate complex logic and make components more readable and maintainable."})]})}}]);
//# sourceMappingURL=57.8a848ab5.chunk.js.map